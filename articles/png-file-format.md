---
title: "PNG仕様から読み解くファイルフォーマットの技術"
emoji: "🖼"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["png"]
published: false
---

# はじめに

PNG（Portable Network Graphics）が誕生したのは1996年、おおよそ24年前のことです（この記事を書いているのは2020年です）。そう考えてみると、たいていの新入社員よりも古参ですね。いまどきの若者たちにとってしてみれば、当時インターネット上で混乱していたGIFの特許問題なんかもあまり知らないのかもしれません。そんな古い歴史もあるPNGファイルフォーマット仕様ですが、現在のWebでもPNGは現役で活躍していて、今後もしばらくは使うことになる画像ファイルフォーマットの1つでしょう。

ところで先日、会社の勉強会の中でCTF（Capture The Flag）を紹介してくれる回がありました。その中の分野の一つにForensicsというものがあって、たとえばPNGやJPEGなどの画像バイナリを解析して問題を解くものがあって非常に面白いなとおもいました。が、どうもそのへんの面白さが弊社新人を含む聴衆には半分ぐらいしか伝わっていなさそうな気がしました。どうやら、そもそもPNGファイルフォーマットとはなんぞや？というところを知らない人が大半で、画像バイナリ解析のことがあまりピンと来ていないのかなと思いました。たしかに、PCやスマートフォンが当たり前の世代にとって、画像ファイルという物自体は理解できていても、そのバイナリがどのようになってるのかというのはそこまで深く追うようなところでもないかもしれません。しかし、画像ファイルフォーマット自体は理解しようとしてみれば（ある程度までは）そんなに難しいものではなく、それでいて奥の深いおもしろみもあるものです。また、画像ファイルの構造を知っていると、プログラム的に応用が効く場面もたまにあります。そんなわけで、改めてこの機会にPNGファイルフォーマットとそのおもしろさについて、若者たちにぜひ知ってほしいなと思った次第です。わたしも若者だけども。まあそういった気持ちがあって、いまこの記事を執筆しています（この記事も会社の勉強会のために筆をとっています）。

PNGファイルフォーマットなどというのは昔から存在するだけあって、十分に学習するための既存の文献はインターネット上に揃ってはいます。もちろん、PNGの正確な仕様は公式の仕様書を読んでもらうのが一番よいです。本記事は仕様をすべて網羅するのではなく、PNGファイルフォーマットに初めて触れる人向けに、重要なポイントとそれらの技術的な概要を記述することを意図しています。本記事はPNGファイルフォーマット仕様に沿って解説をするのですが、真に伝えたいのは下記のようなことです。

- 画像ファイルフォーマットを読み解くと、先人がいかにデジタル画像を取り扱おうとしたのかがわかるよ
- 画像ファイルフォーマットがわかると、世界の見え方が少し変わるよ
- 画像ファイルフォーマット仕様を読むと楽しいよ

## なぜ我々には画像ファイルフォーマットが必要なのか

PNGのファイルフォーマット仕様に触れる前に、画像とはそもそもなんでしょうか？[Wikipedia: 画像](https://ja.wikipedia.org/wiki/%E7%94%BB%E5%83%8F)では下記のように書かれています。

> 画像（がぞう）とは、事象を視覚的に媒体に定着させたもの

画像とは、漢字の通り、画の像と捉えてみてもよいでしょう。我々はその画像を視覚的に移す媒体としてコンピュータ（とそのディスプレイ装置）を使って取り扱いたいわけです。

コンピューター上で何らかのものを取り扱うためには、原理的に0と1のデジタルな値の集合にする必要があります。そのため、我々がコンピュータ上で取り扱う画像はデジタル画像とも呼ばれます。デジタル画像では標本化と量子化により、かならず画素（色）の境界が存在することになります。標本化と量子化に関する詳細はここでは省くのですが、標本化はデジタル画像に変換したときにどれだけ解像度（横幅と縦幅）を大きくできるか、量子化においてはどれだけ色の精度を細かくできるかという問題になってきます。解像度が高ければ高いほど、デジタル画像にする前のアナログの画像に近い状態になるはずですし、色の精度もより細かいほうがアナログの画像と同等の状態に近づくはずです。しかし、無限に解像度を高くしたり、無限に色の精度を細かくすることはできません。コンピューターにも取り扱える情報の上限があるからです。

画像ファイルフォーマットは、有限なコンピューターの性能の中で、適切なデジタル画像に関する情報の保持方法を規定します。デジタル画像を取り扱うシチュエーションによっても、必要な情報の量というのは変わります。たとえば、Web上の画像と、印刷に使う画像では必要な解像度が異なります（一般的に印刷物のほうがより高い解像度が必要）。シチュエーションにも合わせて適度に保持する情報をコントロールできることが必要となるわけです。あまり解像度が必要ないシチュエーションでは画像サイズを小さく保存したり、また色の精度が重要ではないときは色精度を落としたり、必要な範囲で柔軟に保存できるのがよい画像ファイルフォーマットといえるかもしれません。そして、あるコンピューターで保存された画像ファイルは、別のコンピューターでも全く同じように表示されてほしいはずです。デジタル画像ならかんたんだろうと思われるかもしれませんが、実際には同じような画像でもディスプレイ装置に依存して画像の見え方というのは簡単に変わってしまいます。単に画素ごとの色のデータだけではなく、ディスプレイ装置に関する情報など、その他画像に関する様々な情報を保存することも画像ファイルフォーマットには求められます。

また、画像ファイルフォーマットとファイル圧縮は切っても切り離せないトピックです。画像ファイルフォーマットにおいて圧縮は必ずしも必要ではありませんが、多くの実用的な画像ファイルフォーマットは圧縮の仕様があるはずです。デジタル画像として保持する情報が多ければ多いほどより高精細な画像になるはずですが、それだけファイルサイズも大きくなります。ファイルサイズを小さくするためには、圧縮の技術が必要になってきます。圧縮の分野で著名な奥村晴彦氏の言葉を借りると、[「いつの時代も CPU は I/O より速い 」](https://oku.edu.mie-u.ac.jp/~okumura/compression/020130/) というのはデジタル画像でも当てはまることです。より高精細な画像を、より小さなファイルサイズで表現できるようになるか？またその圧縮・展開速度は十分に高速になるのか？というのは画像ファイルフォーマットにおいて大変重要なポイントです。

画像ファイルフォーマットがなぜ必要なのかという点で簡単にまとめると、デジタル画像においてより多くの必要な情報をどれだけ効率的に詰め込めるか？そして効率的に取り出せるか？という問題の解決策こそが画像ファイルフォーマットと言えるでしょう。

今回は画像ファイルフォーマットとしてPNGだけを紹介しますが、デジタルに画像の情報を保持する方法は無限にありえることに気がつくはずです。また、より良い画像フォーマットにするための先人の様々な工夫も垣間見えることでしょう。もしかすると、画像ファイルフォーマットの仕組みに触れることで、まだ誰にも考えついていない、よりよい画像ファイルフォーマットというものも思いつく人も居るかもしれません。

# PNGの概要と特徴

さて、画像とはなんだろうという長い前置きは適当に忘れてもらって、本筋であるPNGについて見ていきたいと思います。

PNGの発音はping（ピン）であると公式の仕様[^1]にも書かれています。が、この発音はIT業界において他の用語とも紛らわしく正確に聞き取りにくいのもあって、ピングと発音する人も多いかもしれません。このドキュメントでは常にPNGと表記しますが、筆者も頭の中ではピングと読みながら書いています。

PNGという画像ファイルフォーマットについて書くべきことはたくさんあるのですが、画像としての主な特徴は下記のようなところになるでしょう。普段PC上でただ画像ファイルを扱っているだけだと、ピンとこない項目もあることでしょう。この記事で全ては紹介しきれないのですが、出てきたタイミングでそれぞれ解説します。

- ラスター画像[^2]
- カラータイプとしてトゥルーカラー、インデックスカラー、グレースケールに対応
- Deflateによる可逆圧縮画像
- 圧縮フィルター
- アルファチャンネルに対応
- インターレースに対応
- ガンマ補正値などの情報の埋め込みに対応
- アニメーションに対応（非公式の拡張仕様だが…）

## 補足: ラスター画像とは

PNGはラスター画像に分類されます。さて、ラスター画像とはどういったものでしょうか？

デジタル画像処理において、画像の形式で最もよくつかわれるのはラスター画像です。ラスター画像は、ピクセル（画像の色情報の最小単位）を長方形に並べた二次元配列と捉えることができます。ピクセルの1行分の集まりがスキャンラインまたはラスターであり、ラスターの集まりがラスター画像となります。なお、デジタル画像処理におけるラスター画像はビットマップ画像とも呼ばれます。（原義的には、ラスター画像 ≒ ビットマップ画像なので注意）

ちなみに現代においては、ピクセルは色情報を持つ小さな正方形と捉えても大きな間違いではないでしょう。現代の一般的なPC上のディスプレイ装置では、ピクセルアスペクト比（ピクセルの横幅と縦幅の比）は通常1:1であり、1ピクセルは正方形として表示されるはずです。ただし、PNGとしては必ずしもピクセルとして正方形を期待しているわけではありません。PNGを表示しているディスプレイ装置のピクセルアスペクト比は1:1ではないかもしれないからです。PNGの仕様でもピクセルアスペクト比を指定するための情報を持っていたりします（pHYsチャンク）。

また、ラスター画像ではない画像の形式として、ベクター画像が挙げられます。ここでは詳細は述べませんが、ベクター画像の代表としてはSVGなどが挙げられます。

# PNGのファイルフォーマット仕様

## 全体構造

|項目|サイズ|データ形式|解説|
|---|---|---|---|
|シグネチャ|8 byte|バイナリ|PNGであることを表す固定のバイナリ値|
|チャンクリスト|可変長|バイナリ|チャンクのリスト（後述）|

PNGの全体構造として、シグネチャとチャンクのリストで構成されています。

## シグネチャ

PNGのシグネチャとして、必ずファイルの最初8バイトに固定のバイナリ値が設定されます。16進数表記で `89 50 4e 47 0d 0a 1a 0a` となっています。

|10進数|16進数|ASCII文字|意味|
|---|---|---|---|
|137|89|非ASCII文字|最初に非ASCII文字を含むことで、テキストファイルではないことを示している|
|80|50|P|PNGのP|
|78|4e|N|PNGのN|
|71|47|G|PNGのG|
|13|0d|\r (CR)|改行コード|
|10|0a|\n (LF)|改行コード|
|26|1a|^Z (SUB)|一定の処理系においてテキストファイルのファイル終端（ソフトEOF）として使われる制御文字[^3]|
|10|0a|\r (CR)|改行コード|

シグネチャ内にCRLFおよびCRが含まれているのは、PNGのバイナリファイルがファイル転送された際の改行コード変換を想定して挿入されています。多くのファイル転送ソフトではテキストファイルと扱ったとき改行コード自動変換が行われることがあります。CRLFのファイルを転送先に合わせてLFに変換したり、もしくは逆の変換が行われます。もしPNGファイルがテキストファイルとして扱われ、改行コード変換が行われてしまった場合、シグネチャの不一致によりエラーを検出することができます。

日本語のWindowsコマンドプロンプトでPNGファイルを表示しようとしてみても面白いでしょう。おそらく下記のように表示されるはずです。（Linux環境なら、代わりに `iconv -f sjis hoge.png` でもほぼ同じ結果が得られます）

```
> type hoge.png
臼NG

>
```

`89 50` はShiftJISで「臼」なので上記のように表示されます。

## チャンク

PNGにおけるデータは、チャンクという構造で保存されています。チャンクは下記のような構造です。

|項目|サイズ|データ形式|解説|
|---|---|---|---|
|Length|4 byte|uint32|Chunk Dataの長さ|
|Chunk Type|4 byte|文字列|このチャンクの種類を表す4文字の名前|
|Chunk Data|可変長|バイナリ|データ部。データが0 byteの場合もある|
|CRC|4 byte|バイナリ|CRC-32による誤り検出符号（後述）|

チャンクが出現する順番はある程度規定はされていますが、規定されている順序以外は任意の順序で保持することができます。チャンクタイプによっては、複数出現する場合もあります。このチャンクという構造により、PNGファイルフォーマットはエンコードやデコードがしやすく、さらに拡張しやすいファイルフォーマットになっています。

### CRC

各チャンクごとにChunk TypeとChunk Dataに基づく[CRC（Cyclic Redundancy Check）](https://ja.wikipedia.org/wiki/%E5%B7%A1%E5%9B%9E%E5%86%97%E9%95%B7%E6%A4%9C%E6%9F%BB)を計算する必要があります。CRCは誤り検出符号の一種です。CRCだけ取っても様々な種類があるのですが、PNGではCRC-32と呼ばれるものを採用しています。CRCに関する理論的な話は別の文献に任せるとして、PNGを扱う上では単純に誤り検出のためにCRCを使っているという点を抑えておけば実用上は問題ないでしょう。

誤り検出とは、データを転送した際などに発生するデータの誤りを検出する方法を指し、様々なものが存在します。CRCの計算結果は、データの一部が異なたとき多くの場合では別の計算結果になります。そのため、PNGのバイナリを受け取った際、CRCを計算した結果に差があれば、何らかのデータの誤りが発生していることが検出できます。

# チャンク一覧

PNGにおいて、様々なチャンクが規定されています。標準仕様では大きく分けて必須のチャンクであるCritical Chunkと、任意のチャンクであるAncillary chunkに分けられています。標準以外にもAdditional chunkなどが別途定義されていますが。本記事では触れません。

Critical Chunkは下記の4つです。PLTEは後述するColor typeによって要否が変わりますが、それ以外は必須のチャンクになります。

|Chunk type|複数配置|意味|順序の制約|
|---|---|---|---|
|IHDR|不可|画像ヘッダ|必ず最初に配置|
|PLTE|不可|パレット|IDATより前|
|IDAT|可|画像データ|複数のIDATは連続している必要がある|
|IEND|不可|画像終端|必ず最後に配置|

また、任意のAncillary chunkは下記のとおりです。

|Chunk type|複数配置|意味|順序の制約|
|---|---|---|---|
|tRNS|不可|透過|PLTEの後かつIDATの前|
|gAMA|不可|画像ガンマ|PLTEとIDATの前|
|cHRM|不可|基礎色度|PLTEとIDATの前|
|sRGB|不可|標準RGB色空間|PLTEとIDATの前。iCCPと共存不可|
|iCCP|不可|組み込みICCプロファイル|PLTEとIDATの前。sRGBと共存不可|
|tEXt|可|テキストデータ|なし|
|zTXt|可|圧縮テキストデータ|なし|
|iTXt|可|国際的テキストデータ|なし|
|bKGD|不可|背景色|PLTEの後かつIDATの前|
|pHYs|不可|物理ピクセル寸法|IDATの前|
|sBIT|不可|有効ビット|PLTEとIDATの前|
|sPLT|可|推奨パレット|IDATの前|
|hIST|不可|パレットヒストグラム|PLTEの後かつIDATの前|
|tIME|不可|画像の最終更新時間|なし|


## IHDR 画像ヘッダ

IHDRは画像ヘッダを表すチャンクで、チャンクとして必ず最初に現れます。

|項目|サイズ|データ形式|解説|
|---|---|---|---|
|Width|4 byte|int32|画像の横幅|
|Height|4 byte|int32|画像の縦幅|
|Bit depth|1 byte|uint8|1つのカラーチャネルあたりのビット深度|
|Color type|1 byte|uint8|カラータイプ|
|Compression method|1 byte|uint8|圧縮方法。0（Deflate）のみ|
|Filter method|1 byte|uint8|フィルターメソッド。0のみ|
|Interlace method|1 byte|uint8|インターレースメソッド|

WidthとHeightは、画像の横幅と縦幅の情報になります。4 byteのintegerと定められており、その最大値は 2^31 -1 (=2147483647)です。2020年現在、DisplayPort2.0の最大解像度である16Kのディスプレイでも横幅は15360です。350dpiで2mの印刷物でも27559です。そのため、現代においては十分大きな上限といえるでしょう。

### Bit depth と Color type

Bit depthとColor typeには密接な関わりがあり、下記のような対応関係があります。

|形式|Color Type|有効なBit depth|解説|
|---|---|---|---|
|グレースケール|0|1, 2, 4, 8, 16|ピクセルの保持する情報が白〜黒のグレースケール値になる|
|トゥルーカラー|2|8, 16|ピクセルの持つ情報がRGB値になる|
|インデックスカラー|3|1, 2, 4, 8|ピクセルの持つ情報がパレットのインデックス値になる|
|アルファ付きグレースケール|4|8, 16|ピクセルの持つ情報がパレットのインデックス値になる|
|アルファ付きトゥルーカラー|6|8, 16|ピクセルの持つ情報がパレットのインデックス値になる|

カラータイプが飛び飛びの値になっていることに気がついたかもしれません。カラータイプは、ビットフラグ値の値になっています。カラータイプは、下記のビットフラグの総計になっています。

- パレットを使用する = 1
- 色を使用する（グレースケールではない） = 2
- アルファチャンネルを使用する = 4

たとえば、インデックスカラーはパレットを使用し、色を使用するが、アルファチャンネルは埋め込めないので 1 + 2 = 3 となっていることがわかります。

トゥルーカラーでは色空間はRGBであり、カラーチャネルはR、G、Bの3つあります。Bit depthは1つのカラーチャネルごとの値なので、Bit depth = 8 の場合は1ピクセルあたり 8 × 3 = 24 bitとなります。たとえば、Web制作ででよく目にするHTMLカラーコードは、1カラーチャネルあたり0〜FF（= 255 = 2^8-1）で、0〜FFFFFFで24bitカラーですね。Bit depth = 16 の場合は1ピクセルあたり48bitとなり、より高精細な色の情報を画像に保持できます。

### Compression method

後述のIDATチャンクを圧縮する方式を指定します。PNGでは0（Deflate）のみが定義されているので、常に[Deflate](https://ja.wikipedia.org/wiki/Deflate)圧縮が必要になります。他の画像ファイルフォーマットでは無圧縮を指定できる場合がありますが、PNGでは常にDeflateが必要です。

もともとPNGの開発経緯であるGIFで使用されているLZW圧縮アルゴリズムの特許問題があったため、Deflateは特許が問題にならないように設計されています。LZ77（LZSS）とハフマン符号を組み合わせた手法です。

PNGではzlib形式（[RFC1950](https://tools.ietf.org/html/rfc1950)）と呼ばれるDeflate圧縮にヘッダ及びフッタが付与された形式で保存されます。マニアックなバイナリアンであれば、IDATの最初の2 byteの `78 9C` `78 01` `78 DA` あたりのいずれかになっていて、zlib形式だと予想することもできるでしょう（zlib形式であればたいていこれら2 byteが出現するのでその筋の人は気がつきやすい）


### Filter method

Filter methodは0のみが定義されており、この場合PNGの仕様で定められているフィルターに従う必要があります。

フィルターとはその名の通り画像データに対するフィルターです。なぜこのフィルターが必要になるかというと、圧縮の最適化（圧縮率の向上や速度改善）のために使います。Compression methodでも書いたとおり、PNGではDeflate圧縮が用いられます。Deflateは符号化する関係上、圧縮前のデータは同一の値や同一のパターンが並んでいる方が圧縮効率が良くなります。そのため、圧縮前にフィルタをかけて、より圧縮しやすいデータに加工するという仕様が定められています。

PNGのフィルターはスキャンライン（つまり画像の1行ごと）毎におこなわれます。スキャンライン毎に、そのスキャンラインで度のフィルターをかけるかを表すFilter type（Filter methodとは別なので注意）が1 byte付与されます。つまり、画像の縦幅がhのとき、h × 1 = h byte ぶん画像データが増加します。

Filter method = 0において、Filter typeは下記の5つが定義されています。

- 0(None): 何もフィルタをかけない
- 1(Sub): 1つ左のピクセルからの差分値にする
- 2(Up): 1つ上のピクセルからの差分値にする
- 3(Average): 左と上のピクセルの平均からの差分値にする
- 4(Paeth): 左、上、左上のピクセルから基づくPaethPredictor関数との差分値にする

たとえば、8bitグレースケール横幅4ピクセルの画像において、あるスキャンラインが `10 11 12 13` だったとします。1ピクセルあたり値が1ずつ増えている画像ですね。この場合はSubフィルターを適用してみると `10 1 1 1` という値になります。`1` が連続することになり、他のスキャンラインでも同様であればこのデータは圧縮効率が前よりも良くなりそうです（実際に良くなるかどうかは、他のスキャンライン値にもよるでしょう）。このとき、Subを表すFilter typeのバイトを最初に付け足して `1 10 1 1 1` というデータとなります。これをすべてのスキャンラインで行い、最終的に圧縮効率のいいデータを目指します。

Subの例を上げましたが、UpとAverageも比較対象が異なるだけで同様です。Paethはちょっと複雑なので仕様を読んでみてください（丸投げ）。

最適なフィルターの選択は、PNGエンコーダー（PNGファイルを生成する処理）の腕の見せどころでもあります。最低限の実装をしたPNGエンコーダーでは、おそらく常にNoneフィルタになっていることでしょう。多くの場合それでも十分ですが、より最適なフィルタを選択できるPNGエンコーダーでは、圧縮効率が異なるはずです。スキャンラインごとの5種類のFilter typeの組み合わせ問題となるため、大きな画像ファイルで組み合わせを全探索するのは現実的ではないでしょう。ほどよいフィルタを高速に見つけ出す技術が必要になります。

### Interlace method

PNGにおいて、インターレースメソッドは2つ定義されています。0がインターレースなし、1がAdam7です。

そもそも最近は[インターレース](https://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%AC%E3%83%BC%E3%82%B9)自体あまり馴染みがないかとおもうのですが、画像を読み込む際に上から下へ順に表示するのではなく、画像全体を表示してから徐々に精細な画像を表示するための技術です。今はネットワークの速度やコンピュータの性能が画像ファイルに対して十分に大きい環境がほとんどなので、必要性はあまりなくなりましたね。

インターレースなしの場合は、IDATの画像データは単純に左上から右下までの順で並べられます。この場合、もし読み込み途中で画像を表示するとなれば、画像の上部のみが表示されて、下部は読み込まれていないので表示できないということになります。

PNGで採用されているAdam7では、画像ファイルを8×8ピクセルの集合に分割した上で、7つのパスに分割します。最初のパスまで読み込まれた段階では8×8ピクセルのうち1ピクセルしかわかりませんが、その代わりに1/64のデータ量だけで画像全体のおおよその色がわかることになります。このパスを読み込んで少しずつ表示することで、PNGでのインターレースを実現しています。

## PLTE パレット

PLTEチャンクはパレットを保持するチャンクです。Color type = 3（インデックスカラー）の場合は必須のチャンクですが、2, 6の場合は任意チャンク、0、4の場合は逆に配置しては行けないチャンクとなります。

PLTEチャンクは下記のような複数の色データで構成されています。

|項目|サイズ|データ形式|解説|
|---|---|---|---|
|色(0)|3 byte|RGB|パレットインデックス0の色|
|…|…|…|…|
|色(n)|3 byte|RGB|パレットインデックスnの色|

1つの色データはRGBで3 byteなので、1つのカラーチャネルあたり8 bitの色深度となります。PLTEチャンクでの出現順が、インデックスカラーにおけるインデックスと一致します。つまり、最初に出現した色はインデックスが0であり、後述のIDATチャンクで指定されたピクセルの値が0の場合は、インデックス0の色という扱いになります。

## IDAT 画像データ

IDATチャンクには画像データ本体が格納されています。前述のIHDRで指定されたCompression method、Filter method、Interlace methodに従ってデータを保持しています。

大きい画像データの場合など、IDATは複数配置される場合があります。IDATのデータが複数存在する場合は、すべてのデータを結合してから展開する必要があります。

## IEND 画像終端

IENDチャンクはPNGファイルの終端を意味するチャンクで、必ず最後に出現します。このチャンクが出現するというだけで役目は果たせるので、IENDはデータ部がなく、Lengthが0のチャンクとなっています。

## tRNS 透過

tRNSチャンクはアルファ値（透明度）を保持することができます。アルファ値のリストの取り扱いは、Color typeによって変わります。

インデックスカラー（Color type = 3）の場合は、パレットインデックス順のアルファ値のリストが格納されます。つまり、パレットインデックス0のアルファ値は、tRNSチャンクで最初に格納されたアルファ値が対応します。

|項目|サイズ|データ形式|解説|
|---|---|---|---|
|アルファ値(0)|1 byte|uint8|パレットインデックス0のアルファ値。0が完全な透明、255が不透明|
|…|…|…|…|
|アルファ値(n)|1 byte|uint8|パレットインデックスnのアルファ値。0が完全な透明、255が不透明|

グレースケール（Color type = 0）の場合は、tRNSには1つのグレイ値のみを格納できます。ピクセルのグレイ値が一致するとき、完全な透明の扱いとなります。それ以外の色は不透明の扱いです。たとえば、8bitグレースケールで `0x00FF` が格納されていれば、白が透過色と扱われ、それ以外は不透明になります。

|項目|サイズ|データ形式|解説|
|---|---|---|---|
|Gray|2 byte|uint16|不透明にするグレイ値|

トゥルーカラー（Color type = 2）の場合は、tRNSには1つのRGB値のみを格納できます。ピクセルのRGB値が一致するとき、完全な透明の扱いとなります。それ以外の色は不透明の扱いです。たとえば、24bitトゥルーカラーで `0x00FF 0x00FF 0x00FF` が格納されていれば、白が透過色と扱われ、それ以外は不透明になります。

|項目|サイズ|データ形式|解説|
|---|---|---|---|
|Red|2 byte|uint16|不透明にするRGBのR|
|Green|2 byte|uint16|不透明にするRGBのG|
|Blue|2 byte|uint16|不透明にするRGBのB|

なお、Color typeが4, 6の場合はすでに画像データにα値を含むので、tRNSチャンクを配置することはできません。

上記仕様を見るとわかるように、Color type 0, 2 の場合は1つしか透過色を選べないという制約がありますが、より柔軟な透明度を設定したいのであれば、Color type 4, 6を選べば問題ありません。

## gAMA 画像ガンマ

gAMAチャンクはPNGをエンコードした環境における[ガンマ値](https://ja.wikipedia.org/wiki/%E3%82%AC%E3%83%B3%E3%83%9E%E5%80%A4)に相当する情報を保持します。チャンク内のデータとしては、ガンマ補正時の1/γの100000倍の整数値が格納されます。たとえば、ガンマ値が2.2の場合、`1/2.2 * 100000 = 45454.5454…` なので、gAMAチャンクには `45454` が格納されます。

|項目|サイズ|データ形式|解説|
|---|---|---|---|
|Gamma|4 byte|uint32|ガンマ補正の100000倍整数値|

2020年現在、一般的な液晶ディスプレイはγ = 2.2となるように調整されているため、ガンマ値を気にするケースは少ないかもしれません。昔は、ディスプレイによってガンマ値が異なる場合があったため、画像データとしてどのようなディスプレイ環境で画像がエンコード（保存）されたのかを情報として保持し、別のガンマ値のディスプレイでも補正をすることで同様の発色に変換するなどが行われていました。現代でも古いMacであればγ = 1.8になっているかもしれません。

## cHRM 基礎色度

cHRMチャンクは赤、緑、青の色度と白色点を保持します。sRGBチャンクやiCCPチャンクが存在する場合は無効になります。

## sRGB 標準RGB色空間

sRGBチャンクは、画像がsRGB色空間に従っていることを意味します。

## iCCP 埋め込みICCプロファイル

iCCPチャンクは、ICCプロファイルを埋め込めます。

## tEXt テキストデータ

tEXtチャンクはテキストデータを画像内に埋め込むチャンクです。テキストのエンコードは ISO/IEC 8859-1 (Latin-1) です。

|項目|サイズ|データ形式|解説|
|---|---|---|---|
|Keyword|1-79 byte|文字列|キーワード|
|Null separator|1 byte|uint8|NULL文字|
|Text|可変長|文字列|任意のテキストデータ|

KeywordもISO/IEC 8859-1 (Latin-1) で、任意のテキストを埋め込むことができます。ただし、PNGの仕様上、特定のキーワードが定義されており、仕様の意図どおりにテキストデータが入力されることを想定されています。

仕様上で明示されているKeywordは下記のとおりです。

|Keyword|意味|
|---|---|
|Title|画像のタイトルやキャプション|
|Author|画像の作者名|
|Description|画像の説明|
|Copyright|画像のコピーライト|
|Software|画像の作成に使用したソフトウェア|
|Disclaimer|法的な免責事項|
|Warning|画像の性質に関する警告|
|Source|画像の作成に使用したデバイス|
|Comment|その他のコメント。またはGIFから変換した際のコメントデータ|


## zTXt 圧縮テキストデータ

zTXtチャンクは圧縮したテキストデータを画像内に埋め込むチャンクです。圧縮されていること以外はtEXtチャンクと同等の使い方を想定されています。

|項目|サイズ|データ形式|解説|
|---|---|---|---|
|Keyword|1-79 byte|文字列|キーワード|
|Null separator|1 byte|uint8|NULL文字|
|Compression method|1 byte|uint8|0（Deflate）のみ|
|Compressed text|可変長|文字列|任意の圧縮されたテキストデータ|

Keywordの取り扱いはtEXtチャンクと同じです。Compression methodは画像データと同様に 0 (Deflate)のみが定義されています。


## iTXt 国際的テキストデータ

iTXtチャンクはUTF-8のテキストデータを画像内に埋め込むチャンクです。zTXtチャンクのように圧縮することも可能です。用途としてはtEXtチャンクと同等の使い方を想定されています。

|項目|サイズ|データ形式|解説|
|---|---|---|---|
|Keyword|1-79 byte|文字列|キーワード|
|Null separator|1 byte|uint8|NULL文字|
|Compression flag|1 byte|uint8|0（無圧縮）または1（圧縮）|
|Compression method|1 byte|uint8|0（Deflate）のみ|
|Language tag|可変長|文字列|言語タグ|
|Null separator|1 byte|uint8|NULL文字|
|text|可変長|文字列|任意のテキストデータ|

Language tagは[RFC-1766](https://tools.ietf.org/html/rfc1766)で規定されている言語タグを格納する必要があります。たとえば、テキストデータが日本語であれば、Language tagは `ja` と入れることになるはずです。

## bKGD 背景色

bKGDチャンクは画像の背景色を指定します。Color typeによって背景色のデータは異なります。なお、画像のビューアーが画像を表示する際に、必ずしもこの背景色を使う必要はありません。ビューアー側で別の背景色を利用することも許容されています。

## pHYs 物理ピクセル寸法

pHYsチャンクは画像の物理的なピクセルの寸法またはピクセルアスペクト比を保持します。

|項目|サイズ|データ形式|解説|
|---|---|---|---|
|Pixels per unit, X axis|4 byte|uint32|単位あたりのピクセル数（X軸）|
|Pixels per unit, Y axis|4 byte|uint32|単位あたりのピクセル数（Y軸）|
|Unit specifier|1 byte|uint8|0(unknown) or 1(メートル)|

Unit specifierが0の場合は単位は未定義となり、ピクセルアスペクト比のみが指定されることになります。たとえばUnit specifierが0で、Pixels per unit, X axis = 1 および Pixels per unit, Y axis = 1ならば、ピクセルアスペクト比は1:1となります。なお、pHYsチャンクが存在しない場合もピクセルアスペクト比1:1の正方形として取り扱われます。

Unit specifierが1の場合はメートルが単位となります。例えば物理的な横幅が20インチでフルHD（1920×1080）のディスプレイ環境でPNGをエンコードした場合、20インチ = 0.508mなので、Pixels per unit, X axis = 1920 * 1/0.508 ≒ 3779 となるはずです。

現代で通常使用するPC用液晶ディスプレイでは、ピクセルアスペクト比は1:1なので、あまり気にすることもないかもしれません。ただし、ディスプレイのピクセルアスペクト比が異なる環境があるため、このような情報が格納できるようになっています。

## sBIT 有効ビット

sBITチャンクはPNGエンコード前の有効なビット深度を格納できます。PNGの仕様上、エンコード元画像のビット深度が7bitだったとしても、8bitや16bitの色深度に変換して格納する必要があります。元画像のビット深度を情報として埋め込むことで、より細かくビット深度を設定できるファイルフォーマットへ変換する場合などに、参考情報として使えます。

## sPLT 推奨パレット

sPLTチャンクは、減色用の推奨パレットを格納できます。

## hIST パレットヒストグラム

hISTチャンクは、PLTEチャンクによるパレットの色が使用される頻度の概算を格納できます。たとえば、ヒストグラムに基づいて減色をする場合に参考となるデータになります。

## tIME 画像の最終更新時間

tIMEチャンクは画像が最終的に更新された時間を格納できます。

# まとめ

PNGのすべての仕様までは紹介しきれていませんが、この記事に記載した分だけでも、様々な技術や工夫が画像ファイルフォーマットに込められていることが伝わったのではないかと思います。今回は特に画像であるPNGに絞って紹介しましたが、世の中にある大抵のファイルフォーマットないしプロトコルでは今回紹介したような技術の粋で構成されていたりします。

みなさんもぜひ、自分の興味のある分野のなにがしかについて、詳細な仕様を読んだり実装して見ることをおすすめします。楽しいので。


[^1]: http://www.libpng.org/pub/png/spec/1.2/PNG-Introduction.html
[^2]: https://ja.wikipedia.org/wiki/%E3%83%93%E3%83%83%E3%83%88%E3%83%9E%E3%83%83%E3%83%97%E7%94%BB%E5%83%8F
[^3]: https://ja.wikipedia.org/wiki/%E7%BD%AE%E6%8F%9B%E6%96%87%E5%AD%97